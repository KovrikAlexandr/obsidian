TLS/SSL – протокол шифрования. Решает следующие задачи:
- При передаче данные не могут быть прочитаны 
- При передаче данные не могут изменены
- Мы можем удостовериться в личности сервера

Артефакты:
- Приватный ключ – хранится на сервере. Нельзя распространять
- Публичный ключ – распространяется свободно (обычно вместе с сертификатом)
- Сертификат – обёртка над публичным ключом (но не только). Содержит информацию о центре сертификации (Certificate Authority), который может подтвердить ключ

## Начало общения клиента и сервера
Сначала происходит TCP Handshake (syn, ack/syn, ack)

Далее идёт TLS Handshake:
- Сервер присылает свой сертификат
- Клиент может увидеть в сертификате, того, кто его выпустил (CA)
- Сертификат содержит подпись CA. Клиент проверяет её достоверность с помощью публичного ключа CA, который хранится у клиента в trusted store

После этого для общения используется симметричное шифрование с помощью сессионного ключа. (тут может использоваться Диффи-Хеллман)

## Как хранятся сертификаты

Может храниться как:
- `.der` (бинарный) 
- `.pem` (ASCII)
- `.crt` – бинарный или ASCII
- `.cert` – бинарный или ASCII

## Какие данные хранит сертификат

Сертификат хранит следующие данные:
- CN (Common Name) – доменное имя, на которое выпущен сертификат
- Публичный ключ сервера (домена)
- Issuer – тот, кто подписал сертификат
- Подпись (сделана приватным ключом CA)

## Проверка подписи

Публичный ключ может определить подпись своего парного приватного ключа.

Как происходит подпись сертификата:
- Issuer берёт бинарный вид сертификата (без подписи) и считает от него хэш
- Хэш подписывается с помощью приватного ключа Issuer-а

Как происходит проверка:
- Клиент берёт публичный ключ из сертификата CA, который хранится в trusted store.
- Клиент сам вычисляет хэш проверяемого сертификата (без подписи)
- Клиент проверяет подпись публичным ключом CA, сравнивая результат с вычисленным хэшем

### Вопросы
- Несколько сертификатов могут храниться в одном файле. Называется bundle. (Зачем это нужно?)
	Это же называется цепочкой (chain) сертификатов. Тут помимо сертификата самого сервера содержатся промежуточные CA, по которым, как по цепочке, можно дойти до корневого CA, про которого клиент должен знать.

- Почему в файлу сертификата не написан домен и центр сертификации?
	Написан, просто, чтобы прочитать надо использовать утилиту openssl. Данные хранятся в бинарном формате, но потом преобразуются в base64 строки, чтобы их можно было передавать как текст.

- Зачем нужен корневой сертификат?
	Он является самоподписанным – нет сертификата, который бы подписывал бы его (есть, но это он сам). Обычно такой сертификат принадлежит CA и хранится в trusted store у клиента

- Что хранится в файле `/etc/ssl/certs/ca-certificates.crt`?
	Тут лежат сертификаты CA. С помощью их публичных ключей можно проверять подлинность сертификата. (Это и есть trusted store)

- Что такое MQTT? 


# Работа с openssl

#### Основные задачи:
- Генерация ключ-пар
- Генерация CSR (запрос на сертификат)
- Генерация сертификата (self-signed или подсписанного CA)


## Генерация ключа

Генерация с помощью алгоритма RSA:
```bash
openssl genrsa -out example-key.pem 4096
```
- `genrsa` – генерация ключа RSA
- `-out` – файл с  результатом
- `4096` – длина ключа (можно использовать и 2048, так быстрее)

Просмотреть информацию о ключе можно так (для RSA):
```bash
openssl rsa -in example-key.pem -text -noout
```
- `rsa` – подкоманда для работы с существующим RSA ключами
- `-in` – файл с входными данными (сам RSA ключ)
- `-text` – человекочитаемый вывод (или хоть какой-нибудь вывод)
- `-noout` – выводит только описание ключа, но не сам ключ

## Генерация сертификата

Создание сертификата из существующего приватного ключа:
```bash
openssl req -x509 -key example-key.pem -out example-cert.pem -days 365
```
- `req` – подкоманда, которая создаёт либо самоподписанный сертификат, либо запрос на подпись у CA (CSR – Certificate Singning Request)
- `-x509` – X.509 это стандарт ключей. Здесь мы явно говорим, что создаём self-signed сертификта
- `-key` – путь к приватному ключу, от которого генерируем сертификат
- `-days` – срок истекания

Сгенерировать и ключ и self-signed сертификат можно в одно действие:
```bash
openssl req \
-days 365 \
-new \
-x509 \
-sha256 \
-newkey rsa:4096 \
-subj "/C=RU/ST=Moscow/L=Moscow/O=self-signed/OU=IT/CN=self-signed-root" \
-noenc \
-keyout root-ca-key.pem \
-out root-ca.pem
```
- `-new` – создаём новый (для `req`)
- `-sha256` –
- `-newkey rsa:4096` – новый RSA ключ длиной в 4096 бит
- `subj` – алгоритм хеширования сертификата перед созданием подписи
- `-noenc` – не зашифровывать приватный ключ
- `-keyout` – файл для приватного ключа

## Подпись сертификата

Пусть мы создали корневой сертификат `root-ca.pem`. И теперь хотим выпустить новые сертификаты, подписанные с помощью корневого.

Для этого создаём новый ключ:
```bash
openssl genrsa -out example-key.pem 4096
```

Теперь создадим CSR (Certificate Signing Request):
```bash
openssl req \
-new \
-subj "/C=RU/ST=Moscow/L=Moscow/O=self-signed/OU=IT/CN=example.com" \
-key example-key.pem \
-out example.csr
```
- Здесь важно указать CN (Common Name)

Теперь можно подписать:
```bash
openssl x509 -req \
-days 365 \
-in example.csr \
-CA root-ca.pem \
-CAkey root-ca-key.pem \
-CAcreateserial \
-sha256 \
-out example.crt
```

## Проверка сертификата

Можно проверить сертификат, отправив запрос:

```bash
openssl s_client -servername dev1-apps-0.ds.sage-next.local \
-connect dev1-apps-0.ds.sage-next.local:443
```

```bash
openssl s_client -servername manul.internal.sage.example.com -connect manul.internal.sage.example.com:443 2>/dev/null
```

```
https://manul.internal.sage.example.com/.well-known/jwks.json
```

```bash
echo | openssl s_client -connect manul.internal.sage.example.com:443 -servername manul.internal.sage.example.com 2>/dev/null | openssl x509 -noout -text | grep -E "Subject:|DNS:"
```