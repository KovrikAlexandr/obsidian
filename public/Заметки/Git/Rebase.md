## База

Подробнее в [статье](https://habr.com/ru/articles/161009/)

Команда в общем виде:
```bash
git rebase [TARGET]
```
- git берёт текущую ветку и по очереди применяет копии(!!!) её коммитов к TARGET. После этого текущая ветка переставляется на последний применённый коммит.

Таким образом, чтобы подтянуть актуальный master в feature ветку:
```bash
git switch feature
git rebase origin/master
git push --force-with-lease
```
- Переключились на `feature` ветку
- Переставляем коммиты на `origin/master`
- Делаем push с флагом `--force-with-lease`


## Разрешение конфликтов

При применении коммитов на каком-то из этапов может возникнуть конфликт. 
В таком случае: 

- Изменения, которые пытается применить коммит остаются в Stage зоне
- Мы находимся в Detached HEAD. HEAD смотрит на последний успешно применённый коммит

Попав в эту ситуацию можно сделать следующее:

1. Прервать rebase:
	```bash
	git rebase --abort
	```

2. Исправить конфликт и продолжить rebase:
	- Проходим по изменённым файлам, разрешая конфликты
	- Добавляем их в Stage:
	- Продолжаем rebase:
		```bash
		git rebase --continue
		```

3. Пропустить коммит (зачем?):
	```bash
	git rebase --skip
	```


## Работа с удалёнными ветками

### Минусы

Если мы делаем rebase

Подтягивать изменения чище через rebase:
```bash
git pull --rebase
```
- git берёт удалённую ветку и применят к ней локальные коммиты в этой ветке (создаёт копии)

По умолчанию pull работает через merge. Можно глобально переопределить это поведение на rebase:
```bash
git config --global pull.rebase true
```

Основная


## Интерактивный rebase


@sitdudz Ревью роли с документацией плиз. Пришлось пару костылей принести:
- Чтобы 



## Вопросы 

- Что такое fast-forward?
- Зачем skip коммита?


